source = { SOI ~ space* ~ (space* ~ toplevel ~ space*)* ~ EOI }
toplevel = { 
	main
	| build
	| test
	| function
	| type_decl
	| task
}

main = {
    main_keyword ~ brace_open ~ body ~ brace_close
}

build = {
    build_keyword ~ brace_open ~ body ~ brace_close
}

test = {
    test_keyword ~ (string_literal)? ~ brace_open ~ body ~ brace_close
}

function = {
    annotation* ~ func_modifiers ~ function_keyword ~ ident ~ param_list ~ return_type? ~ brace_open ~ body ~ brace_close
}
return_type = { arrow ~ type_item }

annotation = ${ "@" ~ ident ~ annotation_params?}
annotation_params = !{ paren_open ~ (ident ~ (comma ~ ident)*)? ~ paren_close }
annotation_arg = { ident | type_ident | string_literal } // TODO: Add number literals here

func_modifiers = {
    async_keyword
    | const_keyword
    | visibility
}

visibility = { pub_keyword? }

type_decl = { struct_type_decl | alias_type_decl | tuple_type_decl | empty_type_decl }
type_decl_prelude = _{ visibility ~ type_keyword ~ type_ident }
struct_type_decl = { type_decl_prelude ~ brace_open ~ struct_fields ~ comma? ~ brace_close }
struct_fields = _{ (struct_field ~ ((comma | newline+) ~ struct_field)*)? }
struct_field = { typed_param }
alias_type_decl = { type_decl_prelude ~ assign_ ~ type_item }
tuple_type_decl = { type_decl_prelude ~ paren_open ~ tuple_fields ~ paren_close }
tuple_fields = _{ (tuple_field ~ (comma ~ tuple_field)*)? }
tuple_field = { type_item }
tuple_element = { element_type }
empty_type_decl = { type_decl_prelude }

param_list = { (paren_open ~ (typed_param ~ (comma ~ typed_param)*)? ~ paren_close)? }
// TODO: Allow patterns here instead of just identifiers
typed_param = _{ ident ~ colon ~ type_item }

task = { ident ~ brace_open ~ body ~ brace_close }

body = { ((newline)* ~ statement ~ (newline)+)* }

statement = { declaration | assignment | expression }

expression = { "TODO: Expression" }

assignment = { ident ~ assignment_operator ~ expression }

declaration = { ref_declaration | val_declaration }
ref_declaration = { ref_keyword ~ ident ~ (colon ~ type_item)? }
val_declaration = { val_keyword ~ ident ~ (colon ~ type_item)? }


ident = @{ used_ident | unused_ident | discard }
used_ident = _{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
unused_ident = _{ "_" ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
discard = _{ "_" }


keyword = _{
    main_keyword
    | build_keyword
    | test_keyword
    | function_keyword
    | type_keyword
    | ref_keyword
    | val_keyword
}


// # Brackets
bracket_open = _{ "[" ~ space* }
bracket_close = _{ space* ~ "]" }
paren_open = _{ "(" ~ space* }
paren_close = _{ space* ~ ")" }
brace_open = _{ "{" ~ space* }
brace_close = _{ space* ~ "}" }

// # Punctuation
colon = _{ ":" }
comma = _{ "," ~ space* }
dot = _{ "." }
semicolon = _{ ";" }

// # Arrows
arrow = _{ "->" }
double_arrow = _{ "=>" }

// # Errors
exclamation_mark = _{ "!" }
question_mark = _{ "?" }

// # Operators
spread = _{".."}
inclusive_range = _{ "..=" }
exclusive_range = _{ "..<" }

assignment_operator = @{ assign | plus_assign | minus_assign | multiply_assign | divide_assign | rem_assign }
assign = @{ assign_ }
assign_ = _{ "=" }
plus_assign = @{ "+=" }
minus_assign = @{ "-=" }
multiply_assign = @{ "*=" }
pow_assign = @{ "**=" }
divide_assign = @{ "/=" }
rem_assign = @{ "%=" }

// ## Arithmetic
plus = @{ "+" }
concat = @{ "++" }
minus = @{ "-" }
multiply = @{ "*" }
pow = @{ "**" }
divide = @{ "/" }
rem = @{ "%" }

// # Keywords
// ## Top-Level
main_keyword = _{ "main" }
build_keyword = _{ "build" }
test_keyword = _{ "test" }
function_keyword = _{ "fn" }
type_keyword = _{ "type" }

// ## Declaration
ref_keyword = @{ "ref" }
val_keyword = @{ "val" }

// ## Function Modifiers
async_keyword = @{ "async" }
const_keyword = @{ "const" }
pub_keyword = @{ "pub" }

// ### Shorthands
ampersand = _{ "&" }
dollar = _{ "$" }

at_sign = @{ "@" }

// # Type Definitions
type_item = { ref_type | result_type | optional_type | allowed_in_error_variant }
// Add some additional restrictions on optional / result type nesting
// - Result types can't be nested -> Flatten result instead
// - Optional types can't be nested -> Flatten optional instead
// - Optional types can't contain result types -> Use Option<Result<_>> if this is needed
// - Result errors can't contain optional types -> If there is no error, the operation should have been successful
// - Result errors can't contain result types -> The error itself should not fail
allowed_in_error_variant = _{ basic_type | array_type | dict_type | ordered_dict_type | set_type | tuple_type }
allowed_in_success_variant = _{ optional_type | ref_type | basic_type | array_type | dict_type | ordered_dict_type | set_type | tuple_type }
allowed_in_optional = _{ basic_type | ref_type| array_type | dict_type | ordered_dict_type | set_type | tuple_type }

error_variant = { allowed_in_error_variant }
success_variant = { allowed_in_success_variant }
ref_element = { allowed_in_error_variant }

key_type = _{ type_item }
value_type = _{ type_item }
element_type = _{ type_item }
opt_element_type = { allowed_in_optional }
tuple_elements = _{ element_type ~ (comma ~ element_type)* }

type_ident = @{ (ASCII_ALPHA_UPPER | "_") ~ (ASCII_ALPHANUMERIC | "_")*}
basic_type = { type_ident }
array_type = !{ bracket_open ~ element_type ~ bracket_close }
set_type = !{ brace_open ~ element_type ~ brace_close }
dict_type = !{ brace_open ~ key_type ~ colon ~ value_type ~ brace_close }
ordered_dict_type = !{ bracket_open ~ key_type ~ colon ~ value_type ~ bracket_close }
tuple_type = !{ paren_open ~ tuple_elements ~ paren_close }
ref_type = ${ dollar ~ ref_element }
borrowed_type = ${ ampersand ~ element_type }
result_type = ${ success_variant ~ exclamation_mark ~ error_variant? }
optional_type = ${ opt_element_type ~ question_mark }

// # Basics
WHITESPACE = _{ whitespace }
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!"\n" ~ ANY)* ~ "\n") }

// ## Whitespace
newline = _{ NEWLINE }
whitespace = _{ " " | "\t" }
space = _{ whitespace | newline }

// ## Literals
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
raw_string_literal = @{ "#\"" ~ (!"\"#" ~ ANY)* ~ "\"#" }
