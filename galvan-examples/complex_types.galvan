pub type IntArray = [Int]

// Use [] for ordered and {} for unordered collections
pub type MyDict = {String : Int}
pub type MySet = {SomeObject}

// TODO: should we use get and set for generating public getters and setters like this?
//	(and if yes: should we omit visibility modifiers since public getters and setters already do this?)
// ...but maybe we want to avoid having autogenerated getters and setters
pub type SomeObject {
	a_heap_reference: stored ref SomeOtherObject
	a_member_with_public_getter: SomeOtherObject get
	set_and_get: SomeOtherObject get set
}


type TupleAlias = (String, String)
type TupleType(String, String)

type OptionalInt = Int?
type FileOrErr = File!
type FileOrIOErr = File!IOError
type OptionalFileOrIOError = File?!IOError
// v-----------------------------^ 
// Order is always: ? before !, this makes it unambigous that ? binds to the Success variant
// --> Alternative to T!?: Use Option<Result<T>>
// 		 TODO: Look how common this is. Maybe it is fine to allow T!? and (T!Error)?
// ! is disallowed in the Error variant
// --> Alternative to nested !: Flatten error type
// ? is disallowed in the Error variant
// --> Alternative to ? in error variant: If there is no error, the operation should have suceeded.
//		Probably it was meant to make the Success type optional instead.