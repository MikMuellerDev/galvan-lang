pub type IntArray = [Int]

// Use [] for ordered and {} for unordered collections
// This is a dict
pub type MyDict = {String : Int}
// This is an ordered dict, this will probably be backed by https://crates.io/crates/indexmap
pub type MyOrderedDict = [String : Int]
// This is a set
pub type MySet = {SomeObject}

// Complex types can be nested
// TODO: Allow complex types in key position, currently only basic types are allowed as dict key
pub type DictOf2DArrays = {String : [[Int]]}

// TODO: should we use get and set for generating public getters and setters like this?
//	(and if yes: should we omit visibility modifiers since public getters and setters already do this?)
// ...but maybe we want to avoid having autogenerated getters and setters
//
// pub type SomeObject {
// 	a_heap_reference: stored ref SomeOtherObject
// 	a_member_with_public_getter: SomeOtherObject get
// 	set_and_get: SomeOtherObject get set
// }


type TupleAlias = (String, String)
type TupleType(String, String)

type OptionalInt = Int?
type FileOrErr = File!
type FileOrIOErr = File!IOError
type OptionalFileOrIOError = File?!IOError
// v-----------------------------^ 
// Order is always: ? before !, this makes it unambigous that ? binds to the Success variant
// --> Alternative to T!?: Use Option<Result<T>>
// 		 TODO: Look how common this is. Maybe it is fine to allow T!? and (T!Error)?
// ! is disallowed in the Error variant
// --> Alternative to nested !: Flatten error type
// ? is disallowed in the Error variant
// --> Alternative to ? in error variant: If there is no error, the operation should have suceeded.
//		Probably it was meant to make the Success type optional instead.
